--------------------------------------------------------------------------------
Makelog started: 2025-02-04 23:29:08
Working directory: /export/projects4/achandra_basicscience/analysis/science_geo/decomp/code
--------------------------------------------------------------------------------
External links successfully created!

  ___  ____  ____  ____  ____ ®
 /__    /   ____/   /   ____/      18.0
___/   /   /___/   /   /___/       MP—Parallel Edition

 Statistics and Data Science       Copyright 1985-2023 StataCorp LLC
                                   StataCorp
                                   4905 Lakeway Drive
                                   College Station, Texas 77845 USA
                                   800-STATA-PC        https://www.stata.com
                                   979-696-4600        stata@stata.com

Stata license: Unlimited-user 4-core network, expiring 17 Nov 2025
Serial number: 501809301897
  Licensed to: Harvard Business School
               Research Computing

Notes:
      1. Stata is running in batch mode.
      2. Unicode is supported; see help unicode_advice.
      3. More than 2 billion observations are allowed; see help obs_advice.
      4. Maximum number of variables is set to 120,000; see help set_maxvar.

. do "/export/projects4/achandra_basicscience/analysis/science_geo/decomp/code/
> analysis.do" 

. set more off

. clear all

. capture log close

. program drop _all

. set scheme modern

. graph set window fontface "Arial Narrow"
not available in non-GUI version

. pause on

. set seed 8975

. global y_name "Productivity"

. global pat_adj_wt_name "Patent-to-Paper Citations"

. global ln_patent_name "Log Patent-to-Paper Citations"

. global ln_y_name "Log Productivity"

. global x_name "Cluster Size"

. global ln_x_name "Log Cluster Size"

. global time year 

. program main
  1.     foreach t in year_firstlast {
  2.         akm, samp(`t') 
  3.     }
  4. end

. program akm
  1.     use ../external/samp/athr_panel_full_comb_`samp', clear
  2.     bys athr_id inst_id : gen count = _n == 1
  3.     bys athr_id: egen mover = total(count) 
  4.     replace mover = mover > 1
  5.     gen ln_y = ln(impact_cite_affl_wt)
  6.     reghdfe ln_y, absorb(inst_fes = inst_id athr_fes = athr_id year) resid
> ual
  7.     predict y_hat , xbd
  8. 
.     corr inst_fes athr_fes
  9.     gcollapse (mean) y_hat inst_fes athr_fes (max) mover, by(inst_id year)
 10.     gcollapse (mean) y_hat inst_fes athr_fes (max) mover, by(inst_id )
 11.     drop if mover == 0
 12.     sum y_hat, d
 13.     local y_var = r(Var)
 14.     sum inst_fes, d
 15.     local inst_var = r(Var)
 16.     sum athr_fes , d
 17.     local athr_var= r(Var)
 18. 
.     di " variance reduction as a function of equalizing place-specific factor
> s = " 1-`athr_var'/`y_var'
 19.     di " variance reduction as a function of equalizing person-specific fa
> ctors = " 1-`inst_var'/`y_var'
 20.     tw hist inst_fes, frac ytitle("Share 
 21. 
. end

. program test 
  1.     syntax, samp(str) timeframe(int) [startyr(int 1945) endyr(int 2023) ym
> ax(real 1) ygap(real 0.2)] 
  2.     cap mat drop _all  
  3.     use if analysis_cond == 1 & inrange(year, `startyr', `endyr')  using $
> {movers}/mover_temp_`samp' , clear  
  4.     merge m:1 athr_id using ${movers}/mover_xw, assert(1 2 3) keep(3) noge
> n
  5.     keep athr_id inst field year msa_comb impact_cite_affl_wt msa_size whi
> ch_place inst_id move_year
  6.     hashsort athr_id year
  7.     gen rel = year - move_year
  8.     merge m:1 athr_id move_year using ${movers}/dest_origin_changes, keep(
> 3) nogen
  9.     hashsort athr_id year
 10.     gegen msa = group(msa_comb)
 11.     rename inst inst_name
 12.     gegen inst = group(inst_id)
 13.     gen ln_y = ln(impact_cite_affl_wt)
 14.     forval i = 1/`timeframe' {
 15.         gen lag`i' = 1 if rel == -`i'
 16.         gen lead`i' = 1 if rel == `i'
 17.     }
 18.     ds lead* lag*
 19.     foreach var in `r(varlist)' {
 20.         replace `var' = 0 if mi(`var')
 21.         replace `var' = `var'*msa_ln_y_diff
 22.     }
 23.     gen treat = msa_ln_y_diff if rel == 0  
 24.     replace treat = 0 if mi(treat)
 25.     local leads
 26.     local lags
 27.     forval i = 1/`timeframe' {
 28.         local leads `leads' lead`i'
 29.         local lags lag`i' `lags'
 30.     }
 31.     gunique athr_id 
 32.     local num_movers = r(unique)
 33.     egen pos_move_size = cut(msa_ln_y_diff) if msa_ln_y_diff > 0, group(2)
 34.     egen neg_move_size = cut(msa_ln_y_diff) if msa_ln_y_diff < 0, group(2)
 35.     bys athr_id: egen l2h_move = max(msa_ln_y_diff > 0)
 36.     bys athr_id: egen h2l_move = max(msa_ln_y_diff < 0)
 37.     local c "inrange(rel,-`timeframe',`timeframe') `cond'"
 38.     local suf = ""
 39.     if "`cond'" == "& l2h_move== 1" {
 40.         local suf = "_l2h"
 41.     }
 42.     else if "`cond'" == "& h2l_move == 1" {
 43.         local suf = "_h2l"
 44.     }
 45.     else if "`cond'" == "& pos_move_size == 0" {
 46.         local suf = "_l2m"
 47.     }
 48.     else if "`cond'" == "& pos_move_size == 1" {
 49.         local suf = "_ll2hh"
 50.     }
 51.     else if "`cond'" == "& neg_move_size == 0" {
 52.         local suf = "_hh2ll"
 53.     }
 54.     else if "`cond'" == "& neg_move_size == 1" {
 55.         local suf = "_h2m"
 56.     }
 57.     mat drop _all
 58.     reghdfe ln_y `lags' treat `leads' if `c' , absorb(year field msa field
> #year field#msa inst_fes = inst athr_fes = athr_id) vce(cluster inst) residua
> ls
 59.     predict y_hat , xb
 60.     gcollapse (mean) y_hat inst_fes athr_fes, by(inst_id year)
 61.     gcollapse (mean) y_hat inst_fes athr_fes, by(inst_id)
 62.     foreach var in y_hat inst_fes athr_fes {
 63.         qui sum `var', d 
 64.         local `var'_var= r(Var)
 65.     }
 66.     di "Share of cross inst variance reduced by equaliazing resachers = " 
> 1 - `inst_fes_var'/`y_hat_var'
 67.     di "Share of cross inst variance reduced by equaliazing place = " 1 - 
> `athr_fes_var'/`y_hat_var'
 68. end

. 
. program output_tables
  1.     syntax, samp(str)
  2.     foreach file in stat { 
  3.          qui matrix_to_txt, saving("../output/tables/`file'_`samp'.txt") m
> atrix(`file'_`samp') ///
>            title(<tab:`file'_`samp'>) format(%20.4f) replace
  4.     }
  5. 
. end

. ** 
. main
file ../external/samp/athr_panel_full_comb_.dta not found
r(601);

end of do-file
r(601);

